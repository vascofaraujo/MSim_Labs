
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Lab3_final</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-05-13"><meta name="DC.source" content="Lab3_final.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Exerc&iacute;cio 5</a></li><li><a href="#3">Modelo SIMULINK 5</a></li><li><a href="#4">Exerc&iacute;cio 6</a></li><li><a href="#6">Modelo SIMULINK 6</a></li><li><a href="#7">Exerc&iacute;cio 7</a></li><li><a href="#9">Exerc&iacute;cio 8</a></li><li><a href="#10">Exerc&iacute;cio 9</a></li><li><a href="#12">Fun&ccedil;&atilde;o findClosest</a></li><li><a href="#13">Exerc&iacute;cio 10</a></li><li><a href="#15">Modelo SIMULINK 10</a></li><li><a href="#16">Exerc&iacute;cio 11</a></li><li><a href="#18">Modelo SIMULINK 11</a></li><li><a href="#19">Exerc&iacute;cio 12</a></li><li><a href="#21">Exerc&iacute;cio 13</a></li><li><a href="#23">Modelo SIMULINK 13</a></li></ul></div><pre class="codeinput"><span class="comment">% LAB 3 - MSIM</span>
<span class="comment">% Autor: Bernardo Rocha &amp; Vasco Ara&uacute;jo</span>
<span class="comment">% N&uacute;mero de Aluno: 89867 &amp; 90817</span>
<span class="comment">% Maio 2020; &Uacute;ltima Revis&atilde;o: 13/05/2020</span>
</pre><h2 id="2">Exerc&iacute;cio 5</h2><pre class="codeinput">clear
close <span class="string">all</span>
clc


<span class="comment">%inicializa&ccedil;&atilde;o de variaveis</span>
g = 9.8;
k = 3;
L = 0.5;
M = 0.15;
l = 0.4;
m = 0.2;
beta = 0.1;
J = m*l^2+(M*L^2)/3;

<span class="comment">%condi&ccedil;oes iniciais</span>
teta0 = 0;
d_teta0 = pi/4;

stop_time = 10;

sim5 = sim(<span class="string">'system5'</span>);

figure(1)
plot(sim5.tout, sim5.teta);
grid <span class="string">on</span>;
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'teta(t)'</span>);
title(<span class="string">'Evolu&ccedil;&atilde;o do &acirc;ngulo de teta(t)'</span>);

figure(2)
plot(sim5.tout, sim5.d_teta);
grid <span class="string">on</span>;
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'d teta(t)'</span>);
title(<span class="string">'Evolu&ccedil;&atilde;o da velocidade de teta(t)'</span>);

figure(3)
plot(sim5.teta, sim5.d_teta);
xlabel(<span class="string">'teta(t)'</span>);
ylabel(<span class="string">'d teta(t)'</span>);
title(<span class="string">'Tra&ccedil;ado de fase'</span>);
</pre><img vspace="5" hspace="5" src="Lab3_final_01.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_02.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_03.png" alt=""> <h2 id="3">Modelo SIMULINK 5</h2><pre class="codeinput">system5
</pre><img vspace="5" hspace="5" src="Lab3_final_04.png" alt=""> <h2 id="4">Exerc&iacute;cio 6</h2><pre class="codeinput">clear
close <span class="string">all</span>
clc


<span class="comment">%inicializa&ccedil;&atilde;o de variaveis</span>
g = 9.8;
k = 3;
L = 0.5;
M = 0.15;
l = 0.4;
m = 0.2;
beta = 0.1;
J = m*l^2+(M*L^2)/3;

stop_time = 10;


<span class="comment">%definir as matrizes de estado</span>
A =  [          0                    1      ;
     ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];

B =  [        0          ;         1/J     ];

C =  [        1                     0       ;
              0                     1      ];

D =  [        0          ;          0      ];

x0 = [        0          ;        pi/4     ];  <span class="comment">% condi&ccedil;oes iniciais</span>

T =  [        0                     0      ];

sim6 = sim(<span class="string">'system6'</span>);

figure(1)
plot(sim6.tout, sim6.y(:,1));
grid <span class="string">on</span>;
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'teta(t)'</span>);
title(<span class="string">'Evolu&ccedil;&atilde;o do &acirc;ngulo de teta(t)'</span>);

figure(2)
plot(sim6.tout, sim6.y(:,2));
grid <span class="string">on</span>;
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'d teta(t)'</span>);
title(<span class="string">'Evolu&ccedil;&atilde;o da velocidade de teta(t)'</span>);

figure(3)
plot(sim6.y(:,1), sim6.y(:,2));
xlabel(<span class="string">'teta(t)'</span>);
ylabel(<span class="string">'d teta(t)'</span>);
title(<span class="string">'Tra&ccedil;ado de fase'</span>);
</pre><img vspace="5" hspace="5" src="Lab3_final_05.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_06.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_07.png" alt=""> <p>Teoricamente obtem-se que a matriz C &eacute; dada por C = [ 1 0 ], uma vez que se tem y = C <img src="Lab3_final_eq08894109528233745697.png" alt="$\cdot$"> x. No entanto, para efeitos de simula&ccedil;&atilde;o a matriz C tem de ser 2x2 devido ao bloco State-Space do SIMULINK, o que at&eacute; acaba por ser conveniente pois fazendo C = [ 1 0 ; 0 1 ] podemos observar o comportamento de <img src="Lab3_final_eq03385156042344747669.png" alt="$x_2$">, que neste caso representa a velocidade de <img src="Lab3_final_eq08288499342375314727.png" alt="$\theta$">(t) de forma a fazermos o tra&ccedil;ado de fase do sistema.</p><h2 id="6">Modelo SIMULINK 6</h2><pre class="codeinput">system6
</pre><img vspace="5" hspace="5" src="Lab3_final_08.png" alt=""> <h2 id="7">Exerc&iacute;cio 7</h2><pre class="codeinput">clear
close <span class="string">all</span>
clc


<span class="comment">%inicializa&ccedil;&atilde;o de variaveis</span>
g = 9.8;
k = 3;
L = 0.5;
M = 0.15;
l = 0.4;
m = 0.2;

J = m*l^2+(M*L^2)/3;

stop_time = 10;


<span class="comment">%definir as matrizes de estado</span>
B =  [        0          ;         1/J     ];

C =  [        1                     0       ;
              0                     1      ];

D =  [        0          ;          0      ];

x0 = [        0          ;        pi/4     ];  <span class="comment">% condi&ccedil;oes iniciais</span>

T =  [        0                     0      ];

<span class="keyword">for</span> i=0:1:1
    beta = i;

    A =  [          0                    1      ;
     ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];

    sim7 = sim(<span class="string">'system6'</span>);

    figure(1)
    plot(sim7.tout, sim7.y(:,1));
    grid <span class="string">on</span>
    hold <span class="string">on</span>

    figure(2)
    plot(sim7.tout, sim7.y(:,2));
    grid <span class="string">on</span>
    hold <span class="string">on</span>

    figure(3)
    plot(sim7.y(:,1), sim7.y(:,2));
    hold <span class="string">on</span>

<span class="keyword">end</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%respostas no plano de estado de diferentes condi&ccedil;oes inicias</span>

<span class="keyword">for</span> beta = 0:1:1
    <span class="comment">%recalcular matriz A</span>
    A =  [          0                    1      ;
        ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];
    <span class="keyword">for</span> p = -5:2:5
        <span class="comment">%mudar condi&ccedil;&aacute;o inicial</span>
        x0 = [p   p];
        sim7_p = sim(<span class="string">'system6'</span>);
        <span class="keyword">if</span> beta == 0
            figure(4)
        <span class="keyword">else</span> figure(5)
        <span class="keyword">end</span>
        plot(sim7_p.y(:,1), sim7_p.y(:,2));
        hold <span class="string">on</span>
        grid <span class="string">on</span>

    <span class="keyword">end</span>
    <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
    <span class="comment">%faz o campo dos vectores (quiver)</span>
    X = linspace(-max(abs(sim7_p.y(:,1)))-1, max(abs(sim7_p.y(:,1)))+1, 15);
    Y = linspace(-max(abs(sim7_p.y(:,2)))-1, max(abs(sim7_p.y(:,2)))+1, 15);

    <span class="keyword">for</span> i = 1:size(X,2)
        <span class="keyword">for</span> j = 1:size(Y,2)
            q = A*[X(i);Y(j)];
            u(j,i) = q(1);
            v(j,i) = q(2);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    quiver(X, Y, u, v,0.7);

    <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
    <span class="comment">%calculo dos valores e vetores proprios</span>
    [vectors, values] = eig(A);
    fprintf(<span class="string">'\n\nPara beta = %d:\n Vectores pr&oacute;prios:\n'</span>, beta);
    disp(vectors);
    fprintf(<span class="string">'\n Valores pr&oacute;prios:\n'</span>);
    disp(values);
<span class="keyword">end</span>

<span class="comment">%calcular valores e vetores proprios de A para o valor de beta da questao 5</span>
beta = 0.1;
A =  [          0                    1      ;
      ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];
[vectors, values] = eig(A);
fprintf(<span class="string">'\n\nPara beta = %.1f:\n Vectores pr&oacute;prios:\n'</span>, beta);
disp(vectors);
fprintf(<span class="string">'\n Valores pr&oacute;prios:\n'</span>);
disp(values);


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%graficos</span>

figure(1)
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'teta(t)'</span>);
title(<span class="string">'Evolu&ccedil;&atilde;o do &acirc;ngulo de teta(t)'</span>);
legend(<span class="string">'beta = 0'</span>, <span class="string">'beta = 1'</span>);

figure(2)
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'d teta(t)'</span>);
title(<span class="string">'Evolu&ccedil;&atilde;o da velocidade de teta(t)'</span>);
legend(<span class="string">'beta = 0'</span>, <span class="string">'beta = 1'</span>);

figure(3)
xlabel(<span class="string">'teta(t)'</span>);
ylabel(<span class="string">'d teta(t)'</span>);
title(<span class="string">'Tra&ccedil;ado de fase'</span>);
legend(<span class="string">'beta = 0'</span>, <span class="string">'beta = 1'</span>);

<span class="keyword">for</span> r = 4:1:5
    figure(r)
    xlabel(<span class="string">'teta(t)'</span>);
    ylabel(<span class="string">'d teta(t)'</span>);
    <span class="keyword">if</span> r == 4
        title(<span class="string">'Tra&ccedil;ado de fase com beta = 0'</span>);
    <span class="keyword">elseif</span> r == 5
        title(<span class="string">'Tra&ccedil;ado de fase com beta = 1'</span>);
    <span class="keyword">end</span>
    leg = legend(<span class="string">'(-5, -5)'</span>, <span class="string">'(-3, -3)'</span>, <span class="string">'(-1, -1)'</span>, <span class="string">'(1, 1)'</span>, <span class="string">'(3, 3)'</span>,<span class="string">'(5, 5)'</span>);
    title(leg, <span class="string">'Pontos iniciais (teta,dteta)'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">

Para beta = 0:
 Vectores pr&oacute;prios:
   0.0000 - 0.1533i   0.0000 + 0.1533i
   0.9882 + 0.0000i   0.9882 + 0.0000i


 Valores pr&oacute;prios:
   0.0000 + 6.4451i   0.0000 + 0.0000i
   0.0000 + 0.0000i   0.0000 - 6.4451i



Para beta = 1:
 Vectores pr&oacute;prios:
    0.4415   -0.0489
   -0.8973    0.9988


 Valores pr&oacute;prios:
   -2.0323         0
         0  -20.4396



Para beta = 0.1:
 Vectores pr&oacute;prios:
  -0.0267 - 0.1510i  -0.0267 + 0.1510i
   0.9882 + 0.0000i   0.9882 + 0.0000i


 Valores pr&oacute;prios:
  -1.1236 + 6.3464i   0.0000 + 0.0000i
   0.0000 + 0.0000i  -1.1236 - 6.3464i

</pre><img vspace="5" hspace="5" src="Lab3_final_09.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_10.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_11.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_12.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_13.png" alt=""> <p>Para <img src="Lab3_final_eq17331442575217596290.png" alt="$\beta$"> = 0, o sistema n&atilde;o tem amortecimento, logo como se pode confirmar pela Figura 1, o &acirc;ngulo <img src="Lab3_final_eq08288499342375314727.png" alt="$\theta$"> oscila indefinidamente de forma constante sem perturba&ccedil;&otilde;es, enquanto que para <img src="Lab3_final_eq17331442575217596290.png" alt="$\beta$"> = 1 o sistema tem amortecimento total e portanto converge bastante r&aacute;pido para 0. Para o caso de <img src="Lab3_final_eq17331442575217596290.png" alt="$\beta$"> = 0 podemos verificar que obtemos no nosso plano de fase uma din&acirc;mica do tipo "Centro", isto deve-se ao facto de os valores pr&oacute;prios serem imagin&aacute;rios puros. Intuitivamente, percebemos que o sistema sem qualquer tipo de atr&iacute;to, permanecer&aacute; em oscila&ccedil;&atilde;o indeterminadamente. J&aacute; no caso de <img src="Lab3_final_eq17331442575217596290.png" alt="$\beta$"> = 1 os nossos valores pr&oacute;rpios s&atilde;o negativos, logo as nossas solu&ccedil;&otilde;es ir&atilde;o tender para a origem, orientando-se e acompanhando os vectores pr&oacute;prios existentes. Fazendo novamente uma an&aacute;lise intuitiva, visto que existe uma for&ccedil;a de atr&iacute;to presente no sistema, a oscila&ccedil;&atilde;o ir&aacute; ser amortecida at&eacute; se anular no limite do tempo.</p><h2 id="9">Exerc&iacute;cio 8</h2><pre class="codeinput">clear
close <span class="string">all</span>
clc


<span class="comment">%inicializa&ccedil;&atilde;o de variaveis</span>
g = 9.8;
k = 3;
L = 0.5;
M = 0.15;
l = 0.4;
m = 0.2;
J = m*l^2+(M*L^2)/3;

beta = 1;

stop_time = 10;


<span class="comment">%definir as matrizes de estado</span>
A =  [          0                    1      ;
     ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];

B =  [        0          ;         1/J     ];

C =  [        1                     0       ;
              0                     1      ];

D =  [        0          ;          0      ];

T =  [        0                     0      ];

<span class="comment">%calculo das condi&ccedil;oes iniciais</span>
[vectors, values] = eig(A);

<span class="keyword">for</span> i = 1:2
    x0 = [vectors(1,i) vectors(2,i)];

    sim8 = sim(<span class="string">'system6'</span>);
    figure(i)
    plot(sim8.y(:,1), sim8.y(:,2));
    title(<span class="string">"Tra&ccedil;ado de fase com condi&ccedil;&otilde;es iniciais: x0 = ["</span> + vectors(1,i) + <span class="string">" ; "</span> + vectors(2,i) + <span class="string">"]"</span>);
    xlabel(<span class="string">'teta(t)'</span>);
    ylabel(<span class="string">'d teta(t)'</span>);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="Lab3_final_14.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_15.png" alt=""> <h2 id="10">Exerc&iacute;cio 9</h2><pre class="codeinput">clear
close <span class="string">all</span>
clc

<span class="comment">%inicializa&ccedil;&atilde;o de variaveis</span>
g = 9.8;
k = 0.35;
L = 0.25;
M = 0.1;
beta = 0.001;

m_lento = 0;
l_lento = 0;
m_allegro = 0;
l_allegro = 0;


<span class="comment">%definir BPMs que queremos (grupo 36 -&gt; X = 3; Y = 6)</span>
X = 3;
Y = 6;

BPM_lento = 50 + 2*(X+1);

BPM_allegro = 150 - 2*(Y+2);

<span class="comment">%para fazermos o dimensionamento iremos correr o modelo para varios valores</span>
<span class="comment">%de m e l at&eacute; encontrarmos o q estiver mais proximo do pretendido</span>
m_array = linspace(0, M, 200);
l_array = linspace(0.05, L, 200);

<span class="comment">%calcula o BPM para cada valor de m e l</span>
<span class="keyword">for</span> i = 1:size(m_array,2)
    <span class="keyword">for</span> j = 1:size(l_array,2)
        m = m_array(i);
        l = l_array(j);

        J = m*l^2+(M*L^2)/3;

        wn(i,j) = sqrt((k-g*(m*l+(M*L/2)))/J);

        epsilon(i,j) = (beta/(2*J*wn(i,j)));

        <span class="comment">%frequencia do oscilador amortecido -&gt; mais fiel q frequencia</span>
        <span class="comment">%natural</span>
        wa(i,j) = wn(i,j)*sqrt(1-epsilon(i,j)^2);

        <span class="comment">%para eliminar os valores complexos</span>
        <span class="keyword">if</span> ~isreal(wa(i,j))
            wa(i,j) = NaN;
        <span class="keyword">end</span>

         BPM_matrix(i,j) = wa(i,j)*60/pi;
   <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%encontra o primeiro valor de m que permite um BPM maior que o BPM_allegro e um BPM</span>
<span class="comment">%menor que o BPM_lento</span>
<span class="keyword">for</span> i = 1:size(m_array,2)
    m_dimensionamento_lento = 0;
    m_dimensionamento_allegro = 0;
    <span class="keyword">for</span> j = 1:size(l_array,2)
        <span class="keyword">if</span> BPM_matrix(i,j) &gt;= BPM_allegro
            m_dimensionamento_allegro = 1;
        <span class="keyword">end</span>
        <span class="keyword">if</span> BPM_matrix(i,j) &lt;= BPM_lento
            m_dimensionamento_lento = 1;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> (m_dimensionamento_lento + m_dimensionamento_allegro) == 2
        index_m_dimensionado = i;
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> m_dimensionamento_lento == 0
    index_m_dimensionado = size(m_array,2);
<span class="keyword">elseif</span> m_dimensionamento_allegro == 0
    index_m_dimensionado = 1;
<span class="keyword">end</span>

[index_l_lento] = findClosest(BPM_matrix, BPM_lento, index_m_dimensionado, size(l_array,2));
[index_l_allegro] = findClosest(BPM_matrix, BPM_allegro, index_m_dimensionado, size(l_array,2));

m_lento = m_array(index_m_dimensionado);
m_allegro = m_lento;
l_lento = l_array(index_l_lento);
l_allegro = l_array(index_l_allegro);


<span class="comment">%%%%%%%%%%%%%%%</span>
<span class="comment">%plot do BPM</span>
figure(1)
surfc(m_array, l_array, BPM_matrix);


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%confirmar o dimensionamento acima</span>

<span class="keyword">for</span> i = 1:2
    <span class="keyword">if</span> i == 1
        m = m_lento;
        l = l_lento;
    <span class="keyword">elseif</span> i == 2
        m = m_allegro;
        l = l_allegro;
    <span class="keyword">end</span>

    <span class="comment">%recalcular matrizes e parametros necessarios para a simula&ccedil;ao</span>
    J = m*l^2+(M*L^2)/3;

    A =  [          0                    1      ;
         ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];

    B =  [        0          ;         1/J     ];

    C =  [        1                     0       ;
                  0                     1      ];

    D =  [        0          ;          0      ];

    T =  [        0                     0      ];

    x0 = [       pi/4                   0      ];  <span class="comment">%condi&ccedil;ao inicial</span>

    stop_time = 60;

    sim9 = sim(<span class="string">'system6'</span>);

    figure(i+1);
    plot(sim9.tout, sim9.y(:,1));

    wn = sqrt((k-g*(m*l+(M*L/2)))/J);
    epsilon = (beta/(2*J*wn));

    <span class="comment">%faz plot da envolvente teorica</span>
    hold <span class="string">on</span>
    plot(sim9.tout, (pi/4)*exp(-epsilon*wn*sim9.tout), <span class="string">'r'</span>);
    plot(sim9.tout, -(pi/4)*exp(-epsilon*wn*sim9.tout), <span class="string">'r'</span>);

    <span class="comment">%estimar BPM</span>
    [peaks, locations] = findpeaks(sim9.y(:,1));

    T_estimada = (sim9.tout(locations(numel(locations))) - sim9.tout(locations(1)))/(numel(locations)-1);

    f_estimada = 1/T_estimada;

    BPM_estimado(i) = 2*f_estimada*60;
<span class="keyword">end</span>


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%graficos</span>

figure(1);
title(<span class="string">'Varia&ccedil;&atilde;o de BPM para diferentes dimensionamentos de m e l'</span>);
xlabel(<span class="string">'m'</span>);
ylabel(<span class="string">'l'</span>);
zlabel(<span class="string">'BPM'</span>);
shading <span class="string">interp</span>;
colorbar;

figure(2);
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'teta(t)'</span>);
title(<span class="string">"Evolu&ccedil;&atilde;o do &acirc;ngulo de teta(t) (modelo linear) com: m = "</span> + m_lento + <span class="string">" ; l = "</span> + l_lento);
legend(<span class="string">"BPM real ="</span> + BPM_estimado(1) + <span class="string">"; BPM te&oacute;rico ="</span> + BPM_lento, <span class="string">"Envolvente te&oacute;rica"</span>);
grid <span class="string">on</span>;

figure(3);
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'teta(t)'</span>);
title(<span class="string">"Evolu&ccedil;&atilde;o do &acirc;ngulo de teta(t) (modelo linear) com: m = "</span> + m_allegro + <span class="string">" ; l = "</span> + l_allegro);
legend(<span class="string">"BPM real ="</span> + BPM_estimado(2) + <span class="string">"; BPM te&oacute;rico ="</span> + BPM_allegro, <span class="string">"Envolvente te&oacute;rica"</span>);
grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="Lab3_final_16.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_17.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_18.png" alt=""> <p>Como podemos verificar pelas Figuras 1 e 2, a evolu&ccedil;&atilde;o de <img src="Lab3_final_eq08288499342375314727.png" alt="$\theta$">(t) ao longo do tempo segue de forma bastante fiel a envolvente te&oacute;rica, como seria de esperar pois a estima&ccedil;&atilde;o do BPM est&aacute; bastante perto do desejado para ambas as cad&ecirc;ncias, n&atilde;o se verificando nenhuma diferen&ccedil;a de maior entre a estima&ccedil;&atilde;o do BPM lento para o allegro.</p><h2 id="12">Fun&ccedil;&atilde;o findClosest</h2><pre class="codeinput">type(<span class="string">'findClosest.m'</span>);
</pre><pre class="codeoutput">
function [index_l] = findClosest(BPM_matrix, BPMtoFind, index_m, size)

oldDiference = abs(BPM_matrix(1,1) - BPMtoFind);
index_l = 1;
    for j = 1:size
        currentDiference = abs(BPM_matrix(index_m,j) - BPMtoFind);
        if currentDiference &lt; oldDiference
            oldDiference = currentDiference;
            index_l = j;         
    end
    



end
</pre><h2 id="13">Exerc&iacute;cio 10</h2><pre class="codeinput">clear <span class="string">all</span>
close <span class="string">all</span>
clc

<span class="comment">%inicializa&ccedil;&atilde;o de variaveis</span>
g = 9.8;
L = 0.25;
M = 0.1;
k = 0.35;
beta = 0.001;
T = 0;

<span class="comment">%condi&ccedil;oes iniciais</span>
teta0 = pi/4;
d_teta0 = 0;

<span class="comment">%valores calculados em 9)</span>
m_lento =  0.068844;
l_lento = 0.25;
m_allegro = m_lento;
l_allegro = 0.11633;

<span class="comment">%definir BPMs que queremos (grupo 36 -&gt; X = 3; Y = 6)</span>
X = 3;
Y = 6;

BPM_lento = 50 + 2*(X+1);

BPM_allegro = 150 - 2*(Y+2);

<span class="comment">%atribuir a m e l os valores dimensionados em 9)</span>
<span class="keyword">for</span> i = 1:2
    <span class="keyword">if</span> i == 1
        m = m_lento;
        l = l_lento;
    <span class="keyword">elseif</span> i == 2
        m = m_allegro;
        l = l_allegro;
    <span class="keyword">end</span>

    J = (3*m*l^2+M*L^2)/3;

    stop_time = 60;

    sim10 = sim(<span class="string">'system10'</span>);

    figure(i)
    plot(sim10.tout, sim10.teta);
    hold <span class="string">on</span>

    <span class="comment">%estimar BPM</span>
    [peaks, locations] = findpeaks(sim10.teta);

    T_estimada = (sim10.tout(locations(numel(locations))) - sim10.tout(locations(1)))/(numel(locations)-1);

    f_estimada = 1/T_estimada;

    BPM_estimado(i) = 2*f_estimada*60;


    <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
    <span class="comment">%queremos otimizar a posi&ccedil;ao da massa m (l) para aproximar BPM</span>
    <span class="comment">%do valor desejado</span>
    l_array = linspace(l-0.001,l+0.001,20);

    <span class="keyword">for</span> j = 1:size(l_array,2)
        l = l_array(j);
        J = (3*m*l^2+M*L^2)/3;
        stop_time = 60;
        sim10_testa_opti = sim(<span class="string">'system10'</span>);
        [peaks_testa_opti, locations_testa_opti] = findpeaks(sim10_testa_opti.teta);
        T_testa_opti = (sim10_testa_opti.tout(locations_testa_opti(numel(locations_testa_opti))) - sim10_testa_opti.tout(locations_testa_opti(1)))/(numel(locations_testa_opti)-1);
        f_testa_opti = 1/T_testa_opti;
        BPM_testa_opti(1,j) = 2*f_testa_opti*60;
    <span class="keyword">end</span>

    <span class="comment">%encontra o valor de BPM mais proximo do desejado</span>
    <span class="keyword">if</span> i == 1
        l_index = findClosest(BPM_testa_opti, BPM_lento, 1, size(l_array,2));
    <span class="keyword">elseif</span> i == 2
        l_index = findClosest(BPM_testa_opti, BPM_allegro, 1, size(l_array,2));
    <span class="keyword">end</span>

    l = l_array(l_index);

    <span class="comment">%volta a correr a simula&ccedil;ao</span>
    J = (3*m*l^2+M*L^2)/3;
    stop_time = 60;

    sim10_otimizado = sim(<span class="string">'system10'</span>);

    figure(i)
    plot(sim10_otimizado.tout, sim10_otimizado.teta);

    <span class="comment">%estimar BPM</span>
    [peaks_otimizado, locations_otimizado] = findpeaks(sim10_otimizado.teta);

    T_estimada_otimizado = (sim10_otimizado.tout(locations_otimizado(numel(locations_otimizado))) - sim10_otimizado.tout(locations_otimizado(1)))/(numel(locations_otimizado)-1);

    f_estimada_otimizado = 1/T_estimada_otimizado;

    BPM_estimado_otimizado(i) = 2*f_estimada_otimizado*60;

<span class="keyword">end</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%graficos</span>
figure(1);
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'teta(t)'</span>);
title(<span class="string">"Evolu&ccedil;&atilde;o do &acirc;ngulo de teta(t) (modelo n&atilde;o linear) "</span>);
leg1 = legend(<span class="string">"BPM real ="</span> + BPM_estimado(1) , <span class="string">"BPM otimizado ="</span> + BPM_estimado_otimizado(1));
title(leg1, <span class="string">"BPM te&oacute;rico ="</span> + BPM_lento);
grid <span class="string">on</span>;

figure(2);
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'teta(t)'</span>);
title(<span class="string">"Evolu&ccedil;&atilde;o do &acirc;ngulo de teta(t) (modelo n&atilde;o linear)"</span>);
leg2 = legend(<span class="string">"BPM real ="</span> + BPM_estimado(2) , <span class="string">"BPM otimizado ="</span> + BPM_estimado_otimizado(2));
title(leg2, <span class="string">"BPM te&oacute;rico ="</span> + BPM_allegro);
grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="Lab3_final_19.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_20.png" alt=""> <p>Como podemos verificar, ao usarmos o dimensionamento calculado em 9) para um modelo n&atilde;o linear do sistema verifica-se que a estima&ccedil;&atilde;o de BPM afastou-se um pouco do valor te&oacute;rico. De maneira a optimizarmos esta estima&ccedil;&atilde;o, assumindo que a massa m &eacute; a mesma, iremos voltar a simular o modelo do sistema para um intervalo de valores na vizinhan&ccedil;a do comprimento l calculado anteriormente e voltamos a proceder &agrave; mesma t&aacute;ctica do 9, isto &eacute;, calculamos o BPM real para todos os dimensionametos e calculamos qual o que tem menor dist&acirc;ncia do valor te&oacute;rico, sendo esse o dimensionamento escolhido para a optimiza&ccedil;&atilde;o.</p><h2 id="15">Modelo SIMULINK 10</h2><pre class="codeinput">system10
</pre><img vspace="5" hspace="5" src="Lab3_final_21.png" alt=""> <h2 id="16">Exerc&iacute;cio 11</h2><pre class="codeinput">clear
close <span class="string">all</span>
clc

<span class="comment">%inicializa&ccedil;&atilde;o de variaveis</span>
g = 9.8;
k = 0.35;
L = 0.25;
M = 0.1;
beta = 0.001;

<span class="comment">%condi&ccedil;oes iniciais</span>
teta0 = pi/4;
d_teta0 = 0;

<span class="comment">%valores calculados em 9)</span>
m_lento =  0.068844;
l_lento = 0.25;
m_allegro = m_lento;
l_allegro = 0.11633;

<span class="comment">%definir BPMs que queremos (grupo 36 -&gt; X = 3; Y = 6)</span>
X = 3;
Y = 6;

BPM_lento = 50 + 2*(X+1);

BPM_allegro = 150 - 2*(Y+2);

T = 0.5;

<span class="keyword">for</span> i = 1:2
    <span class="keyword">if</span> i == 1
        m = m_lento;
        l = l_lento;
    <span class="keyword">elseif</span> i == 2
        m = m_allegro;
        l = l_allegro;
    <span class="keyword">end</span>

    J = (3*m*l^2+M*L^2)/3;

    stop_time = 60;

    sim11 = sim(<span class="string">'system11'</span>);

    figure(i)
    plot(sim11.tout, sim11.teta);
    hold <span class="string">on</span>
    plot(sim11.tout, sim11.binario);

    <span class="comment">%estimar BPM</span>
    [peaks, locations] = findpeaks(sim11.teta);

    T_estimada = (sim11.tout(locations(numel(locations))) - sim11.tout(locations(1)))/(numel(locations)-1);

    f_estimada = 1/T_estimada;

    BPM_estimado(i) = 2*f_estimada*60;

<span class="keyword">end</span>


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%graficos</span>
figure(1);
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'teta(t)'</span>);
leg = legend(<span class="string">"Teta(t)"</span>, <span class="string">"Bin&aacute;rio"</span>);
title(leg, <span class="string">"BPM real ="</span> + BPM_estimado(1) + <span class="string">"; BPM te&oacute;rico ="</span> + BPM_lento);
title(<span class="string">"Evolu&ccedil;&atilde;o do &acirc;ngulo teta(t) e do bin&aacute;rio externo aplicado"</span>);
grid <span class="string">on</span>;

figure(2);
xlabel(<span class="string">'Tempo [s]'</span>);
ylabel(<span class="string">'teta(t)'</span>);
leg = legend(<span class="string">"Teta(t)"</span>, <span class="string">"Bin&aacute;rio"</span>);
title(leg, <span class="string">"BPM real ="</span> + BPM_estimado(2) + <span class="string">"; BPM te&oacute;rico ="</span> + BPM_allegro);
title(<span class="string">"Evolu&ccedil;&atilde;o do &acirc;ngulo teta(t) e do bin&aacute;rio externo aplicado"</span>);
grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="Lab3_final_22.png" alt=""> <img vspace="5" hspace="5" src="Lab3_final_23.png" alt=""> <p>Como se pode verificar, a aplica&ccedil;&atilde;o de um bin&aacute;rio externo ao sistema afecta bastante a frequ&ecirc;ncia de oscila&ccedil;&atilde;o pretendida, mas no entanto verifica-se que consegue evitar o decaimento do sistema oscilat&oacute;rio e com isso obt&eacute;m-se uma oscila&ccedil;&atilde;o constante ao longo do tempo. Isto deve-se ao facto de estarmos a contrariar as for&ccedil;as de atrito e grav&iacute;ticas do sistema que t&ecirc;m contribui&ccedil;&otilde;es para o amortecimento da oscila&ccedil;&atilde;o. Podemos concluir tamb&eacute;m que o nosso bin&aacute;rio externo, caso seja maior do que o suposto, acaba por acelerar a oscila&ccedil;&atilde;o do metr&oacute;nomo, causando um aumento significativo na frequ&ecirc;ncia de oscila&ccedil;&atilde;o, desfasando-se do pretendido.</p><h2 id="18">Modelo SIMULINK 11</h2><pre class="codeinput">system11
</pre><img vspace="5" hspace="5" src="Lab3_final_24.png" alt=""> <h2 id="19">Exerc&iacute;cio 12</h2><pre class="codeinput">clear
close <span class="string">all</span>
clc

<span class="comment">%inicializa&ccedil;&atilde;o de variaveis</span>
g = 9.8;
k = 0.35;
L = 0.25;
M = 0.1;
beta = 0.001;

<span class="comment">%condi&ccedil;oes iniciais</span>
teta0 = pi/4;
d_teta0 = 0;

<span class="comment">%valores calculados em 9)</span>
m_lento =  0.068844;
l_lento = 0.25;
m_allegro = m_lento;
l_allegro = 0.11633;

<span class="comment">%definir BPMs que queremos (grupo 36 -&gt; X = 3; Y = 6)</span>
X = 3;
Y = 6;

BPM_lento = 50 + 2*(X+1);

BPM_allegro = 150 - 2*(Y+2);

T = 0.5;

<span class="keyword">for</span> i = 1:2
    <span class="keyword">if</span> i == 1
        m = m_lento;
        l = l_lento;
    <span class="keyword">elseif</span> i == 2
        m = m_allegro;
        l = l_allegro;
    <span class="keyword">end</span>

    J = m*l^2+(M*L^2)/3;
    wn = sqrt((k-g*(m*l+(M*L/2)))/J);
    epsilon = (beta/(2*J*wn));
    G = 1/((wn^2)*J);

    Gs = G*tf(wn^2, [ 1 , (2*epsilon*wn) , wn^2 ] );

    bode(Gs);
    hold <span class="string">on</span>

<span class="keyword">end</span>

figure(1)
grid <span class="string">on</span>
legend(<span class="string">"BPM lento"</span>, <span class="string">"BPM allegro"</span>);
</pre><img vspace="5" hspace="5" src="Lab3_final_25.png" alt=""> <p>Como se pode verificar, para o BPM mais elevado o diagrama de bode est&aacute; deslocado para a direita em rela&ccedil;&atilde;o ao BPM mais pequeno, o que &eacute; expect&aacute;vel pois o BPM varia linearmente com a frequ&ecirc;ncia. Tamb&eacute;m se verifica que o ganho para o BPM allegro &eacute; inferior.</p><h2 id="21">Exerc&iacute;cio 13</h2><pre class="codeinput">clear
close <span class="string">all</span>
clc

<span class="comment">%inicializa&ccedil;&atilde;o de variaveis</span>
g = 9.8;
k = 0.35;
L = 0.25;
M = 0.1;
beta = 0.001;
m = 0.07;
l = 0.12;

J = m*l^2+(M*L^2)/3;
wn_teorico = sqrt((k-g*(m*l+(M*L/2)))/J);


T = 0.5;

<span class="comment">%definir as matrizes de estado</span>
A =  [          0                    1      ;
     ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];

B =  [        0          ;         1/J     ];

C =  [        1                     0       ;
              0                     1      ];

D =  [        0          ;          0      ];

x0 = [        0          ;        pi/4     ];  <span class="comment">% condi&ccedil;oes iniciais</span>

stop_time = 60;

<span class="comment">%cria um array de frequencias</span>
f_array = linspace(0, 10, 500);

<span class="comment">%cria um array com amplitudes</span>
a_array = zeros(1,size(f_array,2));

max_a = 0;
max_a_index = 1;

<span class="keyword">for</span> i = 1:size(f_array,2)
    f = f_array(i);

    sim13 = sim(<span class="string">'system13'</span>);

    a_array(i) = mean(sim13.y(:,1));

    <span class="keyword">if</span>(a_array(i) &gt; max_a)
        max_a = a_array(i);
        max_a_index = i;
    <span class="keyword">end</span>

<span class="keyword">end</span>

wn = 2*pi*f_array(max_a_index);

m_estimado = (k-wn^2*(M*(L^2)/3)-(g*M*L/2))/((wn^2)*(l^2)+g*l);

fprintf(<span class="string">"\n m real = "</span>);
disp(m);
fprintf(<span class="string">"\n m estimado = "</span>);
disp(m_estimado);

figure(1)
plot(f_array, a_array);

grid <span class="string">on</span>;
xlabel(<span class="string">'Frequ&ecirc;ncia [Hz]'</span>);
ylabel(<span class="string">'Amplitude [V]'</span>);
</pre><pre class="codeoutput">
 m real =     0.0700


 m estimado =     0.1932

</pre><img vspace="5" hspace="5" src="Lab3_final_26.png" alt=""> <p>Como se pode confirmar pela quest&atilde;o 11, apesar de o mecanismo de relojoaria que aplica um bin&aacute;rio externo resolver o problema do decaimento para zero do sistema, obtendo assim ondula&ccedil;&otilde;es constantes, o que &eacute; o que se pretende quando se usa um metr&oacute;nomo. Apesar disso, podemos verificar que a frequ&ecirc;ncia de oscila&ccedil;&atilde;o est&aacute; bastante longe da pretendida, o que torna este mecanismo in&uacute;til para uma aplica&ccedil;&atilde;o pr&aacute;ctica pois se o metr&oacute;nomo n&atilde;o consegue oscilar &agrave; frequ&ecirc;ncia pretendida com um erro m&iacute;nimo nao tem nenhum uso pr&aacute;ctico. Para contrariar isto desenvolve-se um sistema mec&acirc;nico para criar uma "balan&ccedil;a". Infelizmento a nossa estima&ccedil;&atilde;o n&atilde;o est&aacute; muito precisa pois temos um erro superior a 100%, o que obviamente est&aacute; errado, mas esta solu&ccedil;&atilde;o poderia possivelmente contrariar o erro causado pela aplica&ccedil;&atilde;o do bin&aacute;rio externo.</p><h2 id="23">Modelo SIMULINK 13</h2><pre class="codeinput">system13
</pre><img vspace="5" hspace="5" src="Lab3_final_27.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
% LAB 3 - MSIM
% Autor: Bernardo Rocha & Vasco Araújo
% Número de Aluno: 89867 & 90817
% Maio 2020; Última Revisão: 13/05/2020   

%% Exercício 5

clear
close all
clc


%inicialização de variaveis
g = 9.8;
k = 3;
L = 0.5;
M = 0.15;
l = 0.4;
m = 0.2;
beta = 0.1;
J = m*l^2+(M*L^2)/3;

%condiçoes iniciais
teta0 = 0;
d_teta0 = pi/4;

stop_time = 10;

sim5 = sim('system5');

figure(1)
plot(sim5.tout, sim5.teta);
grid on;
xlabel('Tempo [s]');
ylabel('teta(t)');
title('Evolução do ângulo de teta(t)');

figure(2)
plot(sim5.tout, sim5.d_teta);
grid on;
xlabel('Tempo [s]');
ylabel('d teta(t)');
title('Evolução da velocidade de teta(t)');

figure(3)
plot(sim5.teta, sim5.d_teta);
xlabel('teta(t)');
ylabel('d teta(t)');
title('Traçado de fase');

%% Modelo SIMULINK 5

system5


%% Exercício 6

clear
close all
clc


%inicialização de variaveis
g = 9.8;
k = 3;
L = 0.5;
M = 0.15;
l = 0.4;
m = 0.2;
beta = 0.1;
J = m*l^2+(M*L^2)/3;

stop_time = 10;


%definir as matrizes de estado
A =  [          0                    1      ;
     ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];

B =  [        0          ;         1/J     ];

C =  [        1                     0       ;
              0                     1      ];

D =  [        0          ;          0      ];
  
x0 = [        0          ;        pi/4     ];  % condiçoes iniciais

T =  [        0                     0      ];

sim6 = sim('system6');

figure(1)
plot(sim6.tout, sim6.y(:,1));
grid on;
xlabel('Tempo [s]');
ylabel('teta(t)');
title('Evolução do ângulo de teta(t)');

figure(2)
plot(sim6.tout, sim6.y(:,2));
grid on;
xlabel('Tempo [s]');
ylabel('d teta(t)');
title('Evolução da velocidade de teta(t)');

figure(3)
plot(sim6.y(:,1), sim6.y(:,2));
xlabel('teta(t)');
ylabel('d teta(t)');
title('Traçado de fase');

%%
% Teoricamente obtem-se que a matriz C é dada por C = [ 1 0 ], uma vez que
% se tem y = C $\cdot$ x. No entanto, para efeitos de simulação a matriz C
% tem de ser 2x2 devido ao bloco State-Space do SIMULINK, o que até acaba
% por ser conveniente pois fazendo C = [ 1 0 ; 0 1 ] podemos observar o
% comportamento de $x_2$, que neste caso representa a velocidade de
% $\theta$(t) de forma a fazermos o traçado de fase do sistema.

%% Modelo SIMULINK 6

system6

%% Exercício 7

clear
close all
clc


%inicialização de variaveis
g = 9.8;
k = 3;
L = 0.5;
M = 0.15;
l = 0.4;
m = 0.2;

J = m*l^2+(M*L^2)/3;

stop_time = 10;


%definir as matrizes de estado
B =  [        0          ;         1/J     ];

C =  [        1                     0       ;
              0                     1      ];

D =  [        0          ;          0      ];
  
x0 = [        0          ;        pi/4     ];  % condiçoes iniciais

T =  [        0                     0      ];

for i=0:1:1
    beta = i;
    
    A =  [          0                    1      ;
     ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];
 
    sim7 = sim('system6');
    
    figure(1)
    plot(sim7.tout, sim7.y(:,1));
    grid on
    hold on
    
    figure(2)
    plot(sim7.tout, sim7.y(:,2));
    grid on
    hold on
    
    figure(3)
    plot(sim7.y(:,1), sim7.y(:,2));
    hold on
    
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%respostas no plano de estado de diferentes condiçoes inicias
 
for beta = 0:1:1
    %recalcular matriz A
    A =  [          0                    1      ;
        ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];
    for p = -5:2:5
        %mudar condiçáo inicial
        x0 = [p   p]; 
        sim7_p = sim('system6');
        if beta == 0
            figure(4)
        else figure(5)
        end
        plot(sim7_p.y(:,1), sim7_p.y(:,2));
        hold on
        grid on
        
    end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %faz o campo dos vectores (quiver)
    X = linspace(-max(abs(sim7_p.y(:,1)))-1, max(abs(sim7_p.y(:,1)))+1, 15);
    Y = linspace(-max(abs(sim7_p.y(:,2)))-1, max(abs(sim7_p.y(:,2)))+1, 15);

    for i = 1:size(X,2)
        for j = 1:size(Y,2) 
            q = A*[X(i);Y(j)];
            u(j,i) = q(1);
            v(j,i) = q(2);
        end
    end
    quiver(X, Y, u, v,0.7);
        
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %calculo dos valores e vetores proprios
    [vectors, values] = eig(A);
    fprintf('\n\nPara beta = %d:\n Vectores próprios:\n', beta);
    disp(vectors);
    fprintf('\n Valores próprios:\n');
    disp(values);
end

%calcular valores e vetores proprios de A para o valor de beta da questao 5
beta = 0.1;
A =  [          0                    1      ;
      ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ]; 
[vectors, values] = eig(A);
fprintf('\n\nPara beta = %.1f:\n Vectores próprios:\n', beta);
disp(vectors);
fprintf('\n Valores próprios:\n');
disp(values);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%graficos

figure(1)
xlabel('Tempo [s]');
ylabel('teta(t)');
title('Evolução do ângulo de teta(t)');
legend('beta = 0', 'beta = 1');

figure(2)
xlabel('Tempo [s]');
ylabel('d teta(t)');
title('Evolução da velocidade de teta(t)');
legend('beta = 0', 'beta = 1');

figure(3)
xlabel('teta(t)');
ylabel('d teta(t)');
title('Traçado de fase');
legend('beta = 0', 'beta = 1');

for r = 4:1:5
    figure(r)
    xlabel('teta(t)');
    ylabel('d teta(t)');
    if r == 4
        title('Traçado de fase com beta = 0');
    elseif r == 5
        title('Traçado de fase com beta = 1');
    end
    leg = legend('(-5, -5)', '(-3, -3)', '(-1, -1)', '(1, 1)', '(3, 3)','(5, 5)');
    title(leg, 'Pontos iniciais (teta,dteta)');
end
    
%%
% Para $\beta$ = 0, o sistema não tem amortecimento, logo como se pode confirmar
% pela Figura 1, o ângulo $\theta$ oscila indefinidamente de forma 
% constante sem perturbações, enquanto que para $\beta$ = 1 o sistema tem
% amortecimento total e portanto converge bastante rápido para 0.
% Para o caso de $\beta$ = 0 podemos verificar que obtemos no nosso plano
% de fase uma dinâmica do tipo "Centro", isto deve-se ao facto de os
% valores próprios serem imaginários puros. Intuitivamente, percebemos que
% o sistema sem qualquer tipo de atríto, permanecerá em oscilação
% indeterminadamente. Já no caso de $\beta$ = 1 os nossos valores prórpios
% são negativos, logo as nossas soluções irão tender para a origem,
% orientando-se e acompanhando os vectores próprios existentes. Fazendo
% novamente uma análise intuitiva, visto que existe uma força de atríto
% presente no sistema, a oscilação irá ser amortecida até se anular no
% limite do tempo.


%% Exercício 8

clear
close all
clc


%inicialização de variaveis
g = 9.8;
k = 3;
L = 0.5;
M = 0.15;
l = 0.4;
m = 0.2;
J = m*l^2+(M*L^2)/3;

beta = 1;

stop_time = 10;


%definir as matrizes de estado
A =  [          0                    1      ;
     ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];

B =  [        0          ;         1/J     ];

C =  [        1                     0       ;
              0                     1      ];

D =  [        0          ;          0      ];
  
T =  [        0                     0      ];

%calculo das condiçoes iniciais
[vectors, values] = eig(A);

for i = 1:2
    x0 = [vectors(1,i) vectors(2,i)];

    sim8 = sim('system6');
    figure(i)
    plot(sim8.y(:,1), sim8.y(:,2));
    title("Traçado de fase com condições iniciais: x0 = [" + vectors(1,i) + " ; " + vectors(2,i) + "]");
    xlabel('teta(t)');
    ylabel('d teta(t)');
end


%% Exercício 9

clear
close all
clc

%inicialização de variaveis
g = 9.8;
k = 0.35;
L = 0.25;
M = 0.1;
beta = 0.001;

m_lento = 0;
l_lento = 0;
m_allegro = 0;
l_allegro = 0;


%definir BPMs que queremos (grupo 36 -> X = 3; Y = 6)
X = 3;
Y = 6;

BPM_lento = 50 + 2*(X+1);

BPM_allegro = 150 - 2*(Y+2);

%para fazermos o dimensionamento iremos correr o modelo para varios valores
%de m e l até encontrarmos o q estiver mais proximo do pretendido
m_array = linspace(0, M, 200);
l_array = linspace(0.05, L, 200);

%calcula o BPM para cada valor de m e l
for i = 1:size(m_array,2)
    for j = 1:size(l_array,2)
        m = m_array(i);
        l = l_array(j);
        
        J = m*l^2+(M*L^2)/3;
        
        wn(i,j) = sqrt((k-g*(m*l+(M*L/2)))/J);
        
        epsilon(i,j) = (beta/(2*J*wn(i,j)));
        
        %frequencia do oscilador amortecido -> mais fiel q frequencia
        %natural
        wa(i,j) = wn(i,j)*sqrt(1-epsilon(i,j)^2);
        
        %para eliminar os valores complexos
        if ~isreal(wa(i,j))
            wa(i,j) = NaN;
        end
        
         BPM_matrix(i,j) = wa(i,j)*60/pi;          
   end
end

%encontra o primeiro valor de m que permite um BPM maior que o BPM_allegro e um BPM
%menor que o BPM_lento
for i = 1:size(m_array,2)
    m_dimensionamento_lento = 0;
    m_dimensionamento_allegro = 0;
    for j = 1:size(l_array,2)
        if BPM_matrix(i,j) >= BPM_allegro
            m_dimensionamento_allegro = 1;
        end
        if BPM_matrix(i,j) <= BPM_lento
            m_dimensionamento_lento = 1;
        end
    end    
    if (m_dimensionamento_lento + m_dimensionamento_allegro) == 2
        index_m_dimensionado = i;
        break;
    end
end
if m_dimensionamento_lento == 0
    index_m_dimensionado = size(m_array,2);
elseif m_dimensionamento_allegro == 0
    index_m_dimensionado = 1;
end

[index_l_lento] = findClosest(BPM_matrix, BPM_lento, index_m_dimensionado, size(l_array,2));
[index_l_allegro] = findClosest(BPM_matrix, BPM_allegro, index_m_dimensionado, size(l_array,2));

m_lento = m_array(index_m_dimensionado);
m_allegro = m_lento;
l_lento = l_array(index_l_lento);
l_allegro = l_array(index_l_allegro);


%%%%%%%%%%%%%%%
%plot do BPM
figure(1)
surfc(m_array, l_array, BPM_matrix);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%confirmar o dimensionamento acima

for i = 1:2
    if i == 1
        m = m_lento;
        l = l_lento;
    elseif i == 2
        m = m_allegro;
        l = l_allegro;
    end
    
    %recalcular matrizes e parametros necessarios para a simulaçao
    J = m*l^2+(M*L^2)/3;

    A =  [          0                    1      ;
         ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];

    B =  [        0          ;         1/J     ];

    C =  [        1                     0       ;
                  0                     1      ];

    D =  [        0          ;          0      ];

    T =  [        0                     0      ];

    x0 = [       pi/4                   0      ];  %condiçao inicial

    stop_time = 60;

    sim9 = sim('system6');

    figure(i+1);
    plot(sim9.tout, sim9.y(:,1));
    
    wn = sqrt((k-g*(m*l+(M*L/2)))/J);       
    epsilon = (beta/(2*J*wn));
    
    %faz plot da envolvente teorica
    hold on
    plot(sim9.tout, (pi/4)*exp(-epsilon*wn*sim9.tout), 'r');
    plot(sim9.tout, -(pi/4)*exp(-epsilon*wn*sim9.tout), 'r');

    %estimar BPM 
    [peaks, locations] = findpeaks(sim9.y(:,1));
    
    T_estimada = (sim9.tout(locations(numel(locations))) - sim9.tout(locations(1)))/(numel(locations)-1);

    f_estimada = 1/T_estimada;
    
    BPM_estimado(i) = 2*f_estimada*60;
end

    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%graficos

figure(1);
title('Variação de BPM para diferentes dimensionamentos de m e l');
xlabel('m');
ylabel('l');
zlabel('BPM');
shading interp;
colorbar;

figure(2);
xlabel('Tempo [s]');
ylabel('teta(t)');
title("Evolução do ângulo de teta(t) (modelo linear) com: m = " + m_lento + " ; l = " + l_lento);
legend("BPM real =" + BPM_estimado(1) + "; BPM teórico =" + BPM_lento, "Envolvente teórica");
grid on;

figure(3);
xlabel('Tempo [s]');
ylabel('teta(t)');
title("Evolução do ângulo de teta(t) (modelo linear) com: m = " + m_allegro + " ; l = " + l_allegro);
legend("BPM real =" + BPM_estimado(2) + "; BPM teórico =" + BPM_allegro, "Envolvente teórica");
grid on;

%% 
% Como podemos verificar pelas Figuras 1 e 2, a evolução de $\theta$(t) ao
% longo do tempo segue de forma bastante fiel a envolvente teórica, como
% seria de esperar pois a estimação do BPM está bastante perto do desejado
% para ambas as cadências, não se verificando nenhuma diferença de maior
% entre a estimação do BPM lento para o allegro.


%% Função findClosest

type('findClosest.m');


%% Exercício 10

clear all
close all
clc

%inicialização de variaveis
g = 9.8;
L = 0.25;
M = 0.1;
k = 0.35;
beta = 0.001;
T = 0;

%condiçoes iniciais
teta0 = pi/4;
d_teta0 = 0;

%valores calculados em 9)
m_lento =  0.068844;
l_lento = 0.25;
m_allegro = m_lento;
l_allegro = 0.11633;

%definir BPMs que queremos (grupo 36 -> X = 3; Y = 6)
X = 3;
Y = 6;

BPM_lento = 50 + 2*(X+1);

BPM_allegro = 150 - 2*(Y+2);

%atribuir a m e l os valores dimensionados em 9)
for i = 1:2   
    if i == 1
        m = m_lento;
        l = l_lento;
    elseif i == 2
        m = m_allegro;
        l = l_allegro;
    end

    J = (3*m*l^2+M*L^2)/3;

    stop_time = 60;

    sim10 = sim('system10');

    figure(i)
    plot(sim10.tout, sim10.teta);
    hold on

    %estimar BPM
    [peaks, locations] = findpeaks(sim10.teta);

    T_estimada = (sim10.tout(locations(numel(locations))) - sim10.tout(locations(1)))/(numel(locations)-1);

    f_estimada = 1/T_estimada;

    BPM_estimado(i) = 2*f_estimada*60;
    
       
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %queremos otimizar a posiçao da massa m (l) para aproximar BPM 
    %do valor desejado
    l_array = linspace(l-0.001,l+0.001,20);
    
    for j = 1:size(l_array,2)
        l = l_array(j);
        J = (3*m*l^2+M*L^2)/3;
        stop_time = 60;
        sim10_testa_opti = sim('system10');
        [peaks_testa_opti, locations_testa_opti] = findpeaks(sim10_testa_opti.teta);
        T_testa_opti = (sim10_testa_opti.tout(locations_testa_opti(numel(locations_testa_opti))) - sim10_testa_opti.tout(locations_testa_opti(1)))/(numel(locations_testa_opti)-1);
        f_testa_opti = 1/T_testa_opti;
        BPM_testa_opti(1,j) = 2*f_testa_opti*60;
    end
    
    %encontra o valor de BPM mais proximo do desejado
    if i == 1
        l_index = findClosest(BPM_testa_opti, BPM_lento, 1, size(l_array,2));
    elseif i == 2
        l_index = findClosest(BPM_testa_opti, BPM_allegro, 1, size(l_array,2));
    end
    
    l = l_array(l_index);

    %volta a correr a simulaçao
    J = (3*m*l^2+M*L^2)/3;
    stop_time = 60;

    sim10_otimizado = sim('system10');

    figure(i)
    plot(sim10_otimizado.tout, sim10_otimizado.teta);

    %estimar BPM
    [peaks_otimizado, locations_otimizado] = findpeaks(sim10_otimizado.teta);

    T_estimada_otimizado = (sim10_otimizado.tout(locations_otimizado(numel(locations_otimizado))) - sim10_otimizado.tout(locations_otimizado(1)))/(numel(locations_otimizado)-1);

    f_estimada_otimizado = 1/T_estimada_otimizado;

    BPM_estimado_otimizado(i) = 2*f_estimada_otimizado*60;
    
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%graficos
figure(1);
xlabel('Tempo [s]');
ylabel('teta(t)');
title("Evolução do ângulo de teta(t) (modelo não linear) ");
leg1 = legend("BPM real =" + BPM_estimado(1) , "BPM otimizado =" + BPM_estimado_otimizado(1));
title(leg1, "BPM teórico =" + BPM_lento);
grid on;

figure(2);
xlabel('Tempo [s]');
ylabel('teta(t)');
title("Evolução do ângulo de teta(t) (modelo não linear)");
leg2 = legend("BPM real =" + BPM_estimado(2) , "BPM otimizado =" + BPM_estimado_otimizado(2));
title(leg2, "BPM teórico =" + BPM_allegro);
grid on;

%%
% Como podemos verificar, ao usarmos o dimensionamento calculado em 9) para
% um modelo não linear do sistema verifica-se que a estimação de BPM
% afastou-se um pouco do valor teórico. De maneira a optimizarmos esta
% estimação, assumindo que a massa m é a mesma, iremos voltar a simular o 
% modelo do sistema para um intervalo de valores na vizinhança do
% comprimento l calculado anteriormente e voltamos a proceder à mesma
% táctica do 9, isto é, calculamos o BPM real para todos os dimensionametos
% e calculamos qual o que tem menor distância do valor teórico, sendo esse
% o dimensionamento escolhido para a optimização.


%% Modelo SIMULINK 10

system10


%% Exercício 11

clear
close all
clc

%inicialização de variaveis
g = 9.8;
k = 0.35;
L = 0.25;
M = 0.1;
beta = 0.001;

%condiçoes iniciais
teta0 = pi/4;
d_teta0 = 0;

%valores calculados em 9)
m_lento =  0.068844;
l_lento = 0.25;
m_allegro = m_lento;
l_allegro = 0.11633;

%definir BPMs que queremos (grupo 36 -> X = 3; Y = 6)
X = 3;
Y = 6;

BPM_lento = 50 + 2*(X+1);

BPM_allegro = 150 - 2*(Y+2);

T = 0.5;

for i = 1:2   
    if i == 1
        m = m_lento;
        l = l_lento;
    elseif i == 2
        m = m_allegro;
        l = l_allegro;
    end

    J = (3*m*l^2+M*L^2)/3;

    stop_time = 60;

    sim11 = sim('system11');
    
    figure(i)
    plot(sim11.tout, sim11.teta);
    hold on
    plot(sim11.tout, sim11.binario);
    
    %estimar BPM 
    [peaks, locations] = findpeaks(sim11.teta);
    
    T_estimada = (sim11.tout(locations(numel(locations))) - sim11.tout(locations(1)))/(numel(locations)-1);

    f_estimada = 1/T_estimada;
    
    BPM_estimado(i) = 2*f_estimada*60;
    
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%graficos
figure(1);
xlabel('Tempo [s]');
ylabel('teta(t)');
leg = legend("Teta(t)", "Binário");
title(leg, "BPM real =" + BPM_estimado(1) + "; BPM teórico =" + BPM_lento);
title("Evolução do ângulo teta(t) e do binário externo aplicado");
grid on;

figure(2);
xlabel('Tempo [s]');
ylabel('teta(t)');
leg = legend("Teta(t)", "Binário");
title(leg, "BPM real =" + BPM_estimado(2) + "; BPM teórico =" + BPM_allegro);
title("Evolução do ângulo teta(t) e do binário externo aplicado");
grid on;

%%
% Como se pode verificar, a aplicação de um binário externo ao sistema
% afecta bastante a frequência de oscilação pretendida, mas no entanto
% verifica-se que consegue evitar o decaimento do sistema oscilatório e com
% isso obtém-se uma oscilação constante ao longo do tempo. Isto deve-se ao
% facto de estarmos a contrariar as forças de atrito e gravíticas do
% sistema que têm contribuições para o amortecimento da oscilação. Podemos
% concluir também que o nosso binário externo, caso seja maior do que o
% suposto, acaba por acelerar a oscilação do metrónomo, causando um aumento 
% significativo na frequência de oscilação, desfasando-se do pretendido.

%% Modelo SIMULINK 11

system11

%% Exercício 12

clear
close all
clc

%inicialização de variaveis
g = 9.8;
k = 0.35;
L = 0.25;
M = 0.1;
beta = 0.001;

%condiçoes iniciais
teta0 = pi/4;
d_teta0 = 0;

%valores calculados em 9)
m_lento =  0.068844;
l_lento = 0.25;
m_allegro = m_lento;
l_allegro = 0.11633;

%definir BPMs que queremos (grupo 36 -> X = 3; Y = 6)
X = 3;
Y = 6;

BPM_lento = 50 + 2*(X+1);

BPM_allegro = 150 - 2*(Y+2);

T = 0.5;

for i = 1:2   
    if i == 1
        m = m_lento;
        l = l_lento;
    elseif i == 2
        m = m_allegro;
        l = l_allegro;
    end

    J = m*l^2+(M*L^2)/3;
    wn = sqrt((k-g*(m*l+(M*L/2)))/J);
    epsilon = (beta/(2*J*wn));
    G = 1/((wn^2)*J);
    
    Gs = G*tf(wn^2, [ 1 , (2*epsilon*wn) , wn^2 ] );
    
    bode(Gs);
    hold on
    
end

figure(1)
grid on
legend("BPM lento", "BPM allegro");

%%
% Como se pode verificar, para o BPM mais elevado o diagrama de bode está
% deslocado para a direita em relação ao BPM mais pequeno, o que é
% expectável pois o BPM varia linearmente com a frequência. Também se
% verifica que o ganho para o BPM allegro é inferior.

%% Exercício 13

clear
close all
clc

%inicialização de variaveis
g = 9.8;
k = 0.35;
L = 0.25;
M = 0.1;
beta = 0.001;
m = 0.07;
l = 0.12;

J = m*l^2+(M*L^2)/3;
wn_teorico = sqrt((k-g*(m*l+(M*L/2)))/J);


T = 0.5;

%definir as matrizes de estado
A =  [          0                    1      ;
     ((-k+g*(m*l+(M*L/2)))/J)    (-beta/J) ];

B =  [        0          ;         1/J     ];

C =  [        1                     0       ;
              0                     1      ];

D =  [        0          ;          0      ];

x0 = [        0          ;        pi/4     ];  % condiçoes iniciais

stop_time = 60;

%cria um array de frequencias
f_array = linspace(0, 10, 500);

%cria um array com amplitudes
a_array = zeros(1,size(f_array,2));

max_a = 0;
max_a_index = 1;

for i = 1:size(f_array,2)  
    f = f_array(i);

    sim13 = sim('system13');
    
    a_array(i) = mean(sim13.y(:,1));

    if(a_array(i) > max_a)
        max_a = a_array(i);
        max_a_index = i;
    end
        
end

wn = 2*pi*f_array(max_a_index);

m_estimado = (k-wn^2*(M*(L^2)/3)-(g*M*L/2))/((wn^2)*(l^2)+g*l);

fprintf("\n m real = ");
disp(m);
fprintf("\n m estimado = ");
disp(m_estimado);

figure(1)
plot(f_array, a_array);

grid on;
xlabel('Frequência [Hz]');
ylabel('Amplitude [V]');

%%
% Como se pode confirmar pela questão 11, apesar de o mecanismo de
% relojoaria que aplica um binário externo resolver o problema do
% decaimento para zero do sistema, obtendo assim ondulações constantes, o
% que é o que se pretende quando se usa um metrónomo. Apesar disso, podemos
% verificar que a frequência de oscilação está bastante longe da
% pretendida, o que torna este mecanismo inútil para uma aplicação práctica
% pois se o metrónomo não consegue oscilar à frequência pretendida com um
% erro mínimo nao tem nenhum uso práctico. Para contrariar isto desenvolve-se um sistema mecânico para criar uma
% "balança". Infelizmento a nossa estimação não está muito precisa pois temos um erro superior a 100%, o que obviamente está errado, mas esta solução poderia
% possivelmente contrariar o erro causado pela aplicação do binário
% externo.

%% Modelo SIMULINK 13

system13
##### SOURCE END #####
--></body></html>